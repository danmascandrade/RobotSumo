/*
 * robot_project_andreas.c
 *
 * Created: 18.05.2015 22:14:06
 *  Author: Andreas Glatz
 */ 

#include <avr/io.h>
#include <avr/interrupt.h>

void init_ddr(void);
void initpwm(void);
void gangschaltung(unsigned char richtung_l, unsigned char richtung_r);

char toggle = 0;
char tim0 = 0;
unsigned char adc1;
unsigned char adc2;
unsigned char adc3;
unsigned char adc4;
unsigned char adcergebnis1;
unsigned char adcergebnis2;
uint16_t findline;
unsigned char direction=0;
unsigned char command=0;
unsigned char counter=0;

void UART_Configuration(){
	UBRRH = 0;
	UBRRL = 51; 					//Baudrate 9600, Asynchronous Normal mode
	UCSRC =(1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0); 	//Frameformat 8Bit, 1 Stopbit, no Parity
	UCSRB =(1<<RXEN)| (1<<RXCIE)|(1<<TXEN);			//receive enabled, rx interrupt enabled
}

void initadc(unsigned char links,unsigned char rechts){
	ADCSRA |= (1<<ADEN);	//|(1<<ADPS2)|(1<<ADPS1)AD-Enable|Prescaler CLK/128
	if ((links == 0 && rechts == 0)|(links == 1 && rechts == 1))
	{
		ADMUX = (1<<REFS0)|(1<<ADLAR);		//ADC0 Select AVCC as Vref, left justify data registers and select ADC0 as input channel
	}
	
	if (links == 1 && rechts == 0)
	{
		ADMUX = (1<<REFS0)|(1<<MUX0)|(1<<MUX1)|(1<<ADLAR);		//ADC3 Select AVCC as Vref, left justify data registers and select ADC0 as input channel
	}
	
	if (links == 0 && rechts == 1)
	{
		ADMUX = (1<<REFS0)|(1<<MUX1)|(1<<ADLAR);		//ADC2 Select AVCC as Vref, left justify data registers and select ADC0 as input channel
	}
	ADCSRA |= (1<<ADSC);				// Start Conversion
}

void gangschaltung(unsigned char richtung_l, unsigned char richtung_r){
	OCR1AH = 0x00;
	OCR1AL = richtung_l;
	
	OCR1BH = 0x00;	//Endwert (Top)
	OCR1BL = richtung_r;
	
}

void initpwm(void){
	
	TCCR1A |= (1<<WGM10)|(1<<COM1A1)|(1<<COM1B1);
	TCCR1B |= (1<<CS11); //Prescaler
	
	ICR1H = 0x00;	//Startwert (Bottom)
	ICR1L = 0x00;
	
	OCR1AH = 0x00;	//Endwert (Top)
	OCR1AL = 0x00;
	
	OCR1BH = 0x00;	//Endwert (Top)
	OCR1BL = 0x00;
	
	
}

void init_ddr(void){			//DDR-config
	//OUTPUT
	DDRB |= (1<<PB1)|(1<<PB2);	//PWM
	DDRC |= (1<<PC4);			//LED
	DDRD |= (1<<PD6)|(1<<PD7);	//motor enable
	DDRD |= (1<<PD4)|(1<<PD5);	//back led
}

void inittim0(void){
		TIMSK |= (1<<TOIE0);         //Overflow Interrupt aktivieren
		TCCR0 |= (1<<CS02)|(1<<CS00);       // Prescaler auf 1 setzen, Takt = 8MHz
}

void linefollow(void)
{
		char x = 25;
		if (adcergebnis1 < x && adcergebnis2 > x)	//at the line right
		{
			findline = 900;
			direction = 1;
			gangschaltung(125,0);
			PORTD |= (1<<PD5);
			PORTD |= (1<<PD4);
			PORTD |= (1<<PD6)|(1<<PD7);
		}
		if (adcergebnis1 > x && adcergebnis2 < x)	//at the line left
		{
			findline = 900;
			direction = 2;
			gangschaltung(0,125);
			PORTD |= (1<<PD5);
			PORTD |= (1<<PD4);
			PORTD |= (1<<PD6)|(1<<PD7);
		}
		if (adcergebnis1 < x && adcergebnis2 < x)	//on the line
		{
			findline = 900;
			gangschaltung(0,0);
			PORTD |= (1<<PD5);
			PORTD |= (1<<PD4);
			PORTD |= (1<<PD6)|(1<<PD7);
		}
		if (adcergebnis1 > x && adcergebnis2 > x) //No line
		{
			findline++;
			
			if (findline<=1600)
			{
				if (direction==2)
				{
					gangschaltung(0,255);
					PORTD |= (1<<PD5);
					PORTD &= ~(1<<PD4);
					PORTD |= (1<<PD7);
					PORTD &= ~(1<<PD6);
				}
				else
				{
					gangschaltung(255,0);
					PORTD |= (1<<PD5);
					PORTD &= ~(1<<PD4);
					PORTD |= (1<<PD6);
					PORTD &= ~(1<<PD7);
				}
			}
			if (findline>1600)
			{
				gangschaltung(255,100);
				PORTD |= (1<<PD5);
				PORTD &= ~(1<<PD4);
				PORTD |= (1<<PD6);
				PORTD &= ~(1<<PD7);
			}
			if (findline>6000)
			{
				gangschaltung(0,0);
				PORTD |= (1<<PD5);
				PORTD |= (1<<PD4);
				PORTD |= (1<<PD6)|(1<<PD7);
			}
			if (findline>8000)
			{
				findline=0;
			}
			
		}
}


void ausgabe(unsigned char temp){
	while(!(UCSRA & (1<<UDRE))){};
	UDR = temp;
	while(!(UCSRA & (1<<TXC))){};
	UCSRA |= (1<<TXC);
}


int main(void)
{

	sei();           // Globale Interrupts aktivieren
	init_ddr();
	initpwm();
	inittim0();
	initadc(1,0);
	UART_Configuration();
	PORTD |= (1<<PD4);
    char x = 3;
	while(1)
    {
		
			if (adcergebnis1 > x)
			{
				gangschaltung(255,0);
			}
			if (adcergebnis2 > x)
			{
				gangschaltung(0,255);
			}
		
    }	
}

ISR(TIMER0_OVF_vect)
{	
	tim0++;
	if (tim0 > 1)
	{
		PORTC |= (1<<PC4);
		if (tim0 > 2)
		{
			tim0 = 0;
			
			
			initadc(1,0);
			adc2 = ADCH;
			initadc(0,1);
			adc3 = ADCH;
			adcergebnis1 = adc1 - adc2;
			adcergebnis2 = adc3 - adc4;	
			ausgabe(adc1);
			ausgabe(adc2);
			ausgabe(adcergebnis1);
			ausgabe(adc3);
			ausgabe(adc4);
			ausgabe(adcergebnis2);
		}
	}
	else
	{
		PORTC &= ~(1<<PC4);
		if (tim0 > 0)
		{
			initadc(1,0);
			adc1 = ADCH;
			initadc(0,1);
			adc4 = ADCH;
		}
	}

}

ISR(USART_RXC_vect){
	
	command=UDR; //commands in main
	
	if (command == 'b')
	{
		gangschaltung(0,0);
		PORTC &= ~(1<<PC4);
		PORTD |= (1<<PD5);
		PORTD |= (1<<PD4);
		PORTD |= (1<<PD6)|(1<<PD7);
	}
	if (command == 'c')
	{
		gangschaltung(255,255);
		PORTC &= ~(1<<PC4);
		PORTD &= ~(1<<PD5);
		PORTD &= ~(1<<PD4);
		PORTD |= (1<<PD6)|(1<<PD7);
	}
}